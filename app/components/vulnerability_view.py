from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel, 
    QTableWidget, QTableWidgetItem, QHeaderView, QSplitter,
    QGroupBox, QFormLayout, QTextEdit, QCheckBox, QComboBox,
    QProgressBar, QMessageBox, QTabWidget, QSpinBox
)
from PyQt5.QtCore import Qt, pyqtSignal
from PyQt5.QtGui import QColor, QBrush, QFont, QIcon

import threading
from datetime import datetime
from typing import Dict, List, Any

from app.utils.logger import get_logger
from app.components.vulnerability_scanner import get_vulnerability_scanner

# Module logger
logger = get_logger('components.vulnerability_view')

class VulnerabilityView(QWidget):
    """User interface component for vulnerability scanning and results."""
    
    # Signals
    status_changed = pyqtSignal(str)  # Emitted when status changes
    scan_started = pyqtSignal()  # Emitted when a scan starts
    scan_completed = pyqtSignal()  # Emitted when a scan completes
    
    def __init__(self, parent=None):
        """Initialize the vulnerability view component."""
        super().__init__(parent)
        
        # Get the vulnerability scanner
        self.scanner = get_vulnerability_scanner()
        
        # Connect scanner signals
        self.scanner.scan_progress.connect(self.update_scan_progress)
        self.scanner.scan_complete.connect(self.handle_scan_complete)
        self.scanner.vulnerability_found.connect(self.handle_vulnerability_found)
        
        # Setup UI
        self.setup_ui()
        
    def setup_ui(self):
        """Set up the user interface."""
        main_layout = QVBoxLayout(self)
        
        # Top controls - buttons for scanning and options
        controls_layout = QHBoxLayout()
        
        self.scan_button = QPushButton("Start Scan")
        self.scan_button.clicked.connect(self.start_scan)
        
        self.stop_button = QPushButton("Stop Scan")
        self.stop_button.clicked.connect(self.stop_scan)
        self.stop_button.setEnabled(False)
        
        self.intensity_combo = QComboBox()
        self.intensity_combo.addItems(["Low", "Medium", "High"])
        self.intensity_combo.setCurrentText("Medium")
        
        self.timeout_spinner = QSpinBox()
        self.timeout_spinner.setRange(1, 10)
        self.timeout_spinner.setValue(2)
        self.timeout_spinner.setSuffix(" sec")
        
        # Add to controls layout
        controls_layout.addWidget(QLabel("Scan Intensity:"))
        controls_layout.addWidget(self.intensity_combo)
        controls_layout.addWidget(QLabel("Timeout:"))
        controls_layout.addWidget(self.timeout_spinner)
        controls_layout.addStretch()
        controls_layout.addWidget(self.scan_button)
        controls_layout.addWidget(self.stop_button)
        
        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setTextVisible(True)
        self.progress_bar.setFormat("%v/%m devices scanned (%p%)")
        self.progress_bar.setVisible(False)
        
        # Main content splitter
        content_splitter = QSplitter(Qt.Vertical)
        
        # Top part - List of vulnerabilities
        vuln_list_group = QGroupBox("Detected Vulnerabilities")
        vuln_list_layout = QVBoxLayout(vuln_list_group)
        
        self.vuln_table = QTableWidget(0, 6)
        self.vuln_table.setHorizontalHeaderLabels(["IP", "Port", "Service", "Vulnerability", "Severity", "Detection Time"])
        self.vuln_table.setSelectionBehavior(QTableWidget.SelectRows)
        self.vuln_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.vuln_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Port column
        self.vuln_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeToContents)  # Severity column
        self.vuln_table.horizontalHeader().setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Time column
        self.vuln_table.setAlternatingRowColors(True)
        self.vuln_table.itemSelectionChanged.connect(self.handle_vulnerability_selection)
        
        vuln_list_layout.addWidget(self.vuln_table)
        
        # Bottom part - Vulnerability details
        vuln_details_group = QGroupBox("Vulnerability Details")
        vuln_details_layout = QVBoxLayout(vuln_details_group)
        
        details_tabs = QTabWidget()
        
        # Overview tab
        overview_tab = QWidget()
        overview_layout = QFormLayout(overview_tab)
        
        self.vuln_name_label = QLabel("No vulnerability selected")
        self.vuln_name_label.setFont(QFont(self.vuln_name_label.font().family(), 12, QFont.Bold))
        
        self.vuln_description_label = QLabel("")
        self.vuln_description_label.setWordWrap(True)
        
        self.vuln_severity_label = QLabel("")
        self.vuln_target_label = QLabel("")
        self.vuln_port_label = QLabel("")
        self.vuln_service_label = QLabel("")
        self.vuln_time_label = QLabel("")
        
        overview_layout.addRow(self.vuln_name_label)
        overview_layout.addRow(QLabel("<hr>"))
        overview_layout.addRow("Description:", self.vuln_description_label)
        overview_layout.addRow("Severity:", self.vuln_severity_label)
        overview_layout.addRow("Target:", self.vuln_target_label)
        overview_layout.addRow("Port/Service:", self.vuln_port_label)
        overview_layout.addRow("Service:", self.vuln_service_label)
        overview_layout.addRow("Detection Time:", self.vuln_time_label)
        
        # Recommendations tab
        recommendations_tab = QWidget()
        recommendations_layout = QVBoxLayout(recommendations_tab)
        
        self.recommendations_text = QTextEdit()
        self.recommendations_text.setReadOnly(True)
        
        recommendations_layout.addWidget(QLabel("Recommended actions to address this vulnerability:"))
        recommendations_layout.addWidget(self.recommendations_text)
        
        # Details tab
        details_tab = QWidget()
        details_layout = QVBoxLayout(details_tab)
        
        self.details_text = QTextEdit()
        self.details_text.setReadOnly(True)
        
        details_layout.addWidget(QLabel("Technical details:"))
        details_layout.addWidget(self.details_text)
        
        # Add tabs
        details_tabs.addTab(overview_tab, "Overview")
        details_tabs.addTab(recommendations_tab, "Recommendations")
        details_tabs.addTab(details_tab, "Details")
        
        vuln_details_layout.addWidget(details_tabs)
        
        # Add to splitter
        content_splitter.addWidget(vuln_list_group)
        content_splitter.addWidget(vuln_details_group)
        content_splitter.setSizes([300, 200])  # Initial sizes
        
        # Stats and summary panel
        stats_layout = QHBoxLayout()
        
        self.summary_label = QLabel("No scan performed yet")
        self.filter_combo = QComboBox()
        self.filter_combo.addItems(["All Severities", "Critical Only", "High & Critical", "Medium & Above"])
        self.filter_combo.currentTextChanged.connect(self.apply_filter)
        
        stats_layout.addWidget(self.summary_label)
        stats_layout.addStretch()
        stats_layout.addWidget(QLabel("Filter:"))
        stats_layout.addWidget(self.filter_combo)
        
        # Add all components to main layout
        main_layout.addLayout(controls_layout)
        main_layout.addWidget(self.progress_bar)
        main_layout.addWidget(content_splitter, 1)  # Give the splitter a stretch factor of 1
        main_layout.addLayout(stats_layout)
        
        # Status label at the bottom
        self.status_label = QLabel("Ready to scan")
        main_layout.addWidget(self.status_label)
    
    def start_scan(self):
        """Start a vulnerability scan on the network devices."""
        # Get scan targets from the main window/network scanner
        targets = self._get_scan_targets()
        
        if not targets:
            QMessageBox.warning(
                self,
                "No Targets",
                "No network devices found to scan.\nPlease perform a network scan first."
            )
            return
        
        # Confirm scan if there are many targets
        if len(targets) > 5:
            reply = QMessageBox.question(
                self,
                "Confirm Scan",
                f"You are about to scan {len(targets)} devices for vulnerabilities.\n"
                f"This may generate network traffic and trigger security alerts.\n\n"
                f"Are you sure you want to continue?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            
            if reply != QMessageBox.Yes:
                return
        
        # Configure scan options
        scan_options = {
            'intensity': self.intensity_combo.currentText().lower(),
            'timeout': self.timeout_spinner.value()
        }
        
        # Start the scan
        success = self.scanner.start_scan(targets, scan_options)
        
        if success:
            # Update UI
            self.scan_button.setEnabled(False)
            self.stop_button.setEnabled(True)
            self.progress_bar.setRange(0, len(targets))
            self.progress_bar.setValue(0)
            self.progress_bar.setVisible(True)
            
            # Clear previous results
            self.clear_results()
            
            # Update status
            self.status_label.setText(f"Scanning {len(targets)} devices for vulnerabilities...")
            self.status_changed.emit(f"Vulnerability scan started on {len(targets)} devices")
            
            # Emit signal
            self.scan_started.emit()
        else:
            # Show error
            QMessageBox.warning(
                self,
                "Scan Error",
                "Could not start vulnerability scan. Another scan may be in progress."
            )
    
    def stop_scan(self):
        """Stop the current vulnerability scan."""
        if self.scanner.stop_scan():
            self.status_label.setText("Vulnerability scan stopped")
            self.status_changed.emit("Vulnerability scan stopped")
            
            # Update UI
            self.scan_button.setEnabled(True)
            self.stop_button.setEnabled(False)
    
    def update_scan_progress(self, current, total):
        """Update the scan progress.
        
        Args:
            current: Current number of devices scanned
            total: Total number of devices to scan
        """
        self.progress_bar.setValue(current)
        self.status_label.setText(f"Scanning device {current} of {total}...")
    
    def handle_scan_complete(self, vulnerabilities, message):
        """Handle scan completion.
        
        Args:
            vulnerabilities: List of detected vulnerabilities
            message: Completion message
        """
        # Update UI
        self.scan_button.setEnabled(True)
        self.stop_button.setEnabled(False)
        self.progress_bar.setVisible(False)
        
        # Update status
        self.status_label.setText(message)
        self.status_changed.emit(message)
        
        # Update summary
        self._update_summary(vulnerabilities)
        
        # Emit signal
        self.scan_completed.emit()
    
    def handle_vulnerability_found(self, vulnerability):
        """Handle a newly found vulnerability.
        
        Args:
            vulnerability: Dictionary with vulnerability details
        """
        # Add to table
        self._add_vulnerability_to_table(vulnerability)
        
        # Update status
        self.status_label.setText(f"Found vulnerability: {vulnerability['name']} on {vulnerability['target']['ip']}")
        
        # If it's critical, notify the parent
        if vulnerability['severity'].lower() == 'critical':
            self.status_changed.emit(f"CRITICAL vulnerability found: {vulnerability['name']} on {vulnerability['target']['ip']}")
    
    def handle_vulnerability_selection(self):
        """Handle selection of a vulnerability from the table."""
        selected_items = self.vuln_table.selectedItems()
        
        if not selected_items:
            # Clear details
            self.vuln_name_label.setText("No vulnerability selected")
            self.vuln_description_label.setText("")
            self.vuln_severity_label.setText("")
            self.vuln_target_label.setText("")
            self.vuln_port_label.setText("")
            self.vuln_service_label.setText("")
            self.vuln_time_label.setText("")
            self.recommendations_text.setText("")
            self.details_text.setText("")
            return
            
        # Get vulnerability data from the first column item
        row = selected_items[0].row()
        item = self.vuln_table.item(row, 0)  # First column (IP)
        
        if not item or not item.data(Qt.UserRole):
            return
            
        vulnerability = item.data(Qt.UserRole)
        
        # Update details
        self._update_vulnerability_details(vulnerability)
    
    def _update_vulnerability_details(self, vulnerability):
        """Update the vulnerability details panel.
        
        Args:
            vulnerability: Dictionary with vulnerability details
        """
        # Basic info
        self.vuln_name_label.setText(vulnerability['name'])
        self.vuln_description_label.setText(vulnerability['description'])
        
        # Severity with color
        severity = vulnerability['severity'].upper()
        if severity.lower() == 'critical':
            severity_text = f'<span style="color: #d9534f; font-weight: bold;">{severity}</span>'
        elif severity.lower() == 'high':
            severity_text = f'<span style="color: #f0ad4e; font-weight: bold;">{severity}</span>'
        elif severity.lower() == 'medium':
            severity_text = f'<span style="color: #5bc0de; font-weight: bold;">{severity}</span>'
        else:
            severity_text = f'<span style="color: #5cb85c;">{severity}</span>'
        self.vuln_severity_label.setText(severity_text)
        
        # Target info
        target = vulnerability['target']
        target_text = f"{target['ip']}"
        if target.get('name'):
            target_text += f" ({target['name']})"
        if target.get('mac'):
            target_text += f" - MAC: {target['mac']}"
        if target.get('vendor'):
            target_text += f" ({target['vendor']})"
        self.vuln_target_label.setText(target_text)
        
        # Port and service
        port = vulnerability.get('port', '')
        service = vulnerability.get('service', '')
        self.vuln_port_label.setText(f"{port}")
        self.vuln_service_label.setText(service)
        
        # Detection time
        if 'detection_time' in vulnerability:
            detection_time = vulnerability['detection_time']
            if isinstance(detection_time, datetime):
                time_str = detection_time.strftime("%Y-%m-%d %H:%M:%S")
            else:
                time_str = str(detection_time)
            self.vuln_time_label.setText(time_str)
        else:
            self.vuln_time_label.setText("Unknown")
        
        # Recommendations
        recommendations = vulnerability.get('recommendations', [])
        if recommendations:
            recommendations_html = "<ul>"
            for rec in recommendations:
                recommendations_html += f"<li>{rec}</li>"
            recommendations_html += "</ul>"
            self.recommendations_text.setHtml(recommendations_html)
        else:
            self.recommendations_text.setPlainText("No specific recommendations available.")
        
        # Details
        details = vulnerability.get('details', {})
        if details:
            details_text = ""
            for key, value in details.items():
                if key != 'method':  # Skip the detection method
                    details_text += f"{key.title()}: {value}\n\n"
            
            # Add any banner information
            if 'banner' in details and details['banner']:
                details_text += f"Service Banner:\n{details['banner']}\n\n"
                
            self.details_text.setPlainText(details_text)
        else:
            self.details_text.setPlainText("No additional details available.")
    
    def _add_vulnerability_to_table(self, vulnerability):
        """Add a vulnerability to the table.
        
        Args:
            vulnerability: Dictionary with vulnerability details
        """
        row = self.vuln_table.rowCount()
        self.vuln_table.insertRow(row)
        
        # IP
        ip_item = QTableWidgetItem(vulnerability['target']['ip'])
        ip_item.setData(Qt.UserRole, vulnerability)  # Store the full data for later use
        self.vuln_table.setItem(row, 0, ip_item)
        
        # Port
        port_item = QTableWidgetItem(str(vulnerability.get('port', '')))
        self.vuln_table.setItem(row, 1, port_item)
        
        # Service
        service_item = QTableWidgetItem(vulnerability.get('service', ''))
        self.vuln_table.setItem(row, 2, service_item)
        
        # Vulnerability name
        name_item = QTableWidgetItem(vulnerability['name'])
        self.vuln_table.setItem(row, 3, name_item)
        
        # Severity (with color)
        severity = vulnerability['severity'].lower()
        severity_item = QTableWidgetItem(severity.upper())
        
        if severity == 'critical':
            severity_item.setForeground(QBrush(QColor('#d9534f')))  # Red
            severity_item.setFont(QFont(severity_item.font().family(), severity_item.font().pointSize(), QFont.Bold))
        elif severity == 'high':
            severity_item.setForeground(QBrush(QColor('#f0ad4e')))  # Orange
            severity_item.setFont(QFont(severity_item.font().family(), severity_item.font().pointSize(), QFont.Bold))
        elif severity == 'medium':
            severity_item.setForeground(QBrush(QColor('#5bc0de')))  # Blue
        else:
            severity_item.setForeground(QBrush(QColor('#5cb85c')))  # Green
            
        self.vuln_table.setItem(row, 4, severity_item)
        
        # Detection time
        if 'detection_time' in vulnerability:
            detection_time = vulnerability['detection_time']
            if isinstance(detection_time, datetime):
                time_str = detection_time.strftime("%Y-%m-%d %H:%M:%S")
            else:
                time_str = str(detection_time)
        else:
            time_str = "Unknown"
        time_item = QTableWidgetItem(time_str)
        self.vuln_table.setItem(row, 5, time_item)
        
        # Apply the current filter
        self.apply_filter(self.filter_combo.currentText())
    
    def _update_summary(self, vulnerabilities):
        """Update the summary information.
        
        Args:
            vulnerabilities: List of detected vulnerabilities
        """
        if not vulnerabilities:
            self.summary_label.setText("No vulnerabilities found")
            return
            
        # Count by severity
        severity_counts = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
        
        for vuln in vulnerabilities:
            severity = vuln['severity'].lower()
            if severity in severity_counts:
                severity_counts[severity] += 1
            else:
                severity_counts['low'] += 1
        
        # Create summary text
        summary = f"Found {len(vulnerabilities)} vulnerabilities: "
        
        if severity_counts['critical'] > 0:
            summary += f"<span style='color: #d9534f; font-weight: bold;'>{severity_counts['critical']} Critical</span>, "
        
        if severity_counts['high'] > 0:
            summary += f"<span style='color: #f0ad4e; font-weight: bold;'>{severity_counts['high']} High</span>, "
        
        if severity_counts['medium'] > 0:
            summary += f"<span style='color: #5bc0de;'>{severity_counts['medium']} Medium</span>, "
        
        if severity_counts['low'] > 0:
            summary += f"<span style='color: #5cb85c;'>{severity_counts['low']} Low</span>, "
        
        # Remove trailing comma and space
        summary = summary.rstrip(", ")
        
        self.summary_label.setText(summary)
    
    def clear_results(self):
        """Clear all vulnerability results."""
        self.vuln_table.setRowCount(0)
        self.summary_label.setText("Scanning...")
        
        # Clear details
        self.vuln_name_label.setText("No vulnerability selected")
        self.vuln_description_label.setText("")
        self.vuln_severity_label.setText("")
        self.vuln_target_label.setText("")
        self.vuln_port_label.setText("")
        self.vuln_service_label.setText("")
        self.vuln_time_label.setText("")
        self.recommendations_text.setText("")
        self.details_text.setText("")
    
    def apply_filter(self, filter_text):
        """Filter the vulnerability table based on severity.
        
        Args:
            filter_text: The filter text (All, Critical Only, etc.)
        """
        filter_text = filter_text.lower()
        
        for row in range(self.vuln_table.rowCount()):
            # Get the severity from the severity column
            severity_item = self.vuln_table.item(row, 4)
            if not severity_item:
                continue
                
            severity = severity_item.text().lower()
            
            # Determine if this row should be shown
            show_row = True
            
            if filter_text == 'critical only':
                show_row = (severity == 'critical')
            elif filter_text == 'high & critical':
                show_row = (severity in ['high', 'critical'])
            elif filter_text == 'medium & above':
                show_row = (severity in ['medium', 'high', 'critical'])
            
            # Show or hide the row
            self.vuln_table.setRowHidden(row, not show_row)
    
    def get_vulnerabilities(self):
        """Get the list of vulnerabilities.
        
        Returns:
            List: List of vulnerability dictionaries
        """
        return self.scanner.get_vulnerabilities()
    
    def _get_scan_targets(self):
        """Get the list of targets to scan.
        
        This method should be implemented to get devices from the main window.
        For now, it returns a list with a single local target for testing.
        
        Returns:
            List: List of target dictionaries
        """
        # Get devices from the main window
        parent_window = self.window()
        
        if hasattr(parent_window, 'devices') and parent_window.devices:
            return parent_window.devices
        
        # If no devices are available, create a test target
        import socket
        try:
            hostname = socket.gethostname()
            local_ip = socket.gethostbyname(hostname)
            return [
                {
                    'ip': local_ip,
                    'mac': '00:00:00:00:00:00',
                    'name': 'Local Machine',
                    'vendor': 'Unknown'
                }
            ]
        except:
            # If we can't get the local IP, use localhost
            return [
                {
                    'ip': '127.0.0.1',
                    'mac': '00:00:00:00:00:00',
                    'name': 'Localhost',
                    'vendor': 'Unknown'
                }
            ] 