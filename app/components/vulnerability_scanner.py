import threading
import socket
import time
import ipaddress
import subprocess
import re
import platform
import json
import os
from typing import Dict, List, Any, Callable, Optional
from datetime import datetime

from PyQt5.QtCore import pyqtSignal, QObject

from app.utils.logger import get_logger

# Module logger
logger = get_logger('components.vulnerability_scanner')

class VulnerabilityScanner(QObject):
    """Component for scanning network devices for vulnerabilities."""
    
    # Signals
    scan_progress = pyqtSignal(int, int)  # emits (current, total)
    scan_complete = pyqtSignal(list, str)  # emits (vulnerabilities, message)
    vulnerability_found = pyqtSignal(dict)  # emits vulnerability details
    
    def __init__(self):
        """Initialize the vulnerability scanner."""
        super().__init__()
        
        # Scanner state
        self.running = False
        self.should_stop = False
        self.scan_thread = None
        
        # Scan results
        self.vulnerabilities = []
        
        # Scan configuration
        self.scan_timeout = 2  # seconds
        self.port_scan_timeout = 0.5  # seconds
        self.max_threads = 10
        self.common_ports = [
            21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 
            143, 443, 445, 993, 995, 1723, 3306, 3389, 5900, 8080
        ]
        self.vulnerability_definitions = self._load_vulnerability_definitions()
    
    def _load_vulnerability_definitions(self) -> Dict:
        """Load vulnerability definitions from a JSON file.
        
        Returns:
            Dict: Vulnerability definitions
        """
        try:
            definitions_path = os.path.join(
                os.path.dirname(os.path.dirname(os.path.dirname(__file__))),
                'data', 'vulnerability_definitions.json'
            )
            
            # Check if the file exists
            if os.path.exists(definitions_path):
                with open(definitions_path, 'r') as f:
                    return json.load(f)
            
            # If file doesn't exist, return default definitions
            logger.warning("Vulnerability definitions file not found. Using default definitions.")
            return self._get_default_definitions()
            
        except Exception as e:
            logger.error(f"Error loading vulnerability definitions: {e}")
            return self._get_default_definitions()
    
    def _get_default_definitions(self) -> Dict:
        """Get default vulnerability definitions.
        
        Returns:
            Dict: Default vulnerability definitions
        """
        return {
            "port_vulnerabilities": {
                "21": {
                    "name": "FTP Server",
                    "description": "FTP service may allow anonymous access or be vulnerable to brute force attacks.",
                    "severity": "medium",
                    "recommendations": [
                        "Disable anonymous access",
                        "Use SFTP instead of FTP",
                        "Implement strong password policies"
                    ]
                },
                "23": {
                    "name": "Telnet Server",
                    "description": "Telnet transmits data in cleartext, including passwords.",
                    "severity": "high",
                    "recommendations": [
                        "Disable Telnet service",
                        "Use SSH instead"
                    ]
                },
                "53": {
                    "name": "DNS Server",
                    "description": "DNS server may be vulnerable to cache poisoning or amplification attacks.",
                    "severity": "medium",
                    "recommendations": [
                        "Update to latest version",
                        "Implement DNSSEC",
                        "Restrict zone transfers"
                    ]
                },
                "139": {
                    "name": "NetBIOS",
                    "description": "NetBIOS service can expose system information and share names.",
                    "severity": "medium",
                    "recommendations": [
                        "Disable NetBIOS if not required",
                        "Use a firewall to restrict access"
                    ]
                },
                "445": {
                    "name": "SMB Server",
                    "description": "SMB service may be vulnerable to attacks like EternalBlue.",
                    "severity": "high",
                    "recommendations": [
                        "Apply latest security patches",
                        "Disable SMBv1",
                        "Use a firewall to restrict access"
                    ]
                },
                "3389": {
                    "name": "Remote Desktop",
                    "description": "RDP service may be susceptible to brute force attacks or BlueKeep vulnerabilities.",
                    "severity": "high",
                    "recommendations": [
                        "Use a strong password",
                        "Enable Network Level Authentication (NLA)",
                        "Use a VPN before connecting to RDP",
                        "Apply latest security patches"
                    ]
                }
            },
            "service_patterns": {
                "SSH": {
                    "pattern": "SSH-2.0-OpenSSH_([0-6]\\.[0-9]|7\\.[0-6])",
                    "name": "Outdated OpenSSH",
                    "description": "Older versions of OpenSSH may contain vulnerabilities.",
                    "severity": "medium",
                    "recommendations": [
                        "Update to the latest version of OpenSSH",
                        "Apply security patches"
                    ]
                },
                "HTTP": {
                    "pattern": "Apache/([0-1]\\.|2\\.0|2\\.1|2\\.2\\.|2\\.3\\.|2\\.4\\.[0-2][0-9])",
                    "name": "Outdated Apache",
                    "description": "Older versions of Apache HTTP Server may contain vulnerabilities.",
                    "severity": "medium",
                    "recommendations": [
                        "Update to the latest version of Apache HTTP Server",
                        "Apply security patches"
                    ]
                }
            },
            "weak_ciphers": {
                "SSL": {
                    "name": "Weak SSL/TLS Configuration",
                    "description": "Server supports weak SSL/TLS protocols or cipher suites.",
                    "severity": "high",
                    "recommendations": [
                        "Disable SSLv2, SSLv3, TLS 1.0, and TLS 1.1",
                        "Enable only strong cipher suites",
                        "Configure perfect forward secrecy"
                    ]
                }
            }
        }
    
    def start_scan(self, targets: List[Dict], scan_options: Dict = None, callback: Callable = None):
        """Start vulnerability scanning on the specified targets.
        
        Args:
            targets: List of target devices to scan (dicts with 'ip', 'mac', etc.)
            scan_options: Dictionary of scan options (ports, intensity, etc.)
            callback: Optional callback function to receive scan results
            
        Returns:
            bool: True if scan started successfully, False otherwise
        """
        if self.running:
            logger.warning("Vulnerability scan already in progress")
            return False
        
        # Reset state
        self.running = True
        self.should_stop = False
        self.vulnerabilities = []
        
        # Apply scan options
        if scan_options:
            self._apply_scan_options(scan_options)
        
        # Start scan in a separate thread
        self.scan_thread = threading.Thread(
            target=self._scan_thread_func,
            args=(targets, callback),
            daemon=True
        )
        self.scan_thread.start()
        
        logger.info(f"Started vulnerability scan on {len(targets)} targets")
        return True
    
    def stop_scan(self):
        """Stop the current vulnerability scan.
        
        Returns:
            bool: True if scan was stopped, False if no scan was running
        """
        if not self.running:
            return False
        
        self.should_stop = True
        if self.scan_thread:
            self.scan_thread.join(timeout=2.0)
        
        self.running = False
        logger.info("Vulnerability scan stopped")
        return True
    
    def get_vulnerabilities(self) -> List[Dict]:
        """Get the list of discovered vulnerabilities.
        
        Returns:
            List[Dict]: List of vulnerability dictionaries
        """
        return self.vulnerabilities.copy()
    
    def _apply_scan_options(self, options: Dict):
        """Apply scan configuration options.
        
        Args:
            options: Dictionary of scan options
        """
        if 'timeout' in options:
            self.scan_timeout = max(1, options['timeout'])
        
        if 'port_timeout' in options:
            self.port_scan_timeout = max(0.1, options['port_timeout'])
        
        if 'max_threads' in options:
            self.max_threads = max(1, min(50, options['max_threads']))
        
        if 'ports' in options and options['ports']:
            self.common_ports = options['ports']
        
        if 'intensity' in options:
            intensity = options['intensity'].lower()
            if intensity == 'low':
                # Quick scan of most common ports
                self.common_ports = [21, 22, 23, 80, 443, 3389]
                self.port_scan_timeout = 0.3
            elif intensity == 'medium':
                # Default
                pass
            elif intensity == 'high':
                # More thorough scan
                self.common_ports = [
                    20, 21, 22, 23, 25, 53, 67, 68, 69, 80, 88, 110, 111, 123, 135, 
                    137, 138, 139, 143, 161, 162, 389, 443, 445, 464, 465, 514, 515, 
                    587, 636, 993, 995, 1080, 1433, 1521, 2049, 2082, 2083, 2086, 
                    2087, 2095, 2096, 3306, 3389, 5432, 5900, 5901, 6000, 8080, 8443
                ]
                self.port_scan_timeout = 0.7
                self.scan_timeout = 3
    
    def _scan_thread_func(self, targets: List[Dict], callback: Optional[Callable]):
        """Main scan thread function.
        
        Args:
            targets: List of target devices to scan
            callback: Optional callback function to receive scan results
        """
        try:
            start_time = time.time()
            total_targets = len(targets)
            
            # Emit initial progress
            self.scan_progress.emit(0, total_targets)
            
            # Process each target
            for i, target in enumerate(targets):
                # Check if we should stop
                if self.should_stop:
                    break
                
                # Scan the target
                self._scan_target(target)
                
                # Update progress
                self.scan_progress.emit(i + 1, total_targets)
                
                # Brief pause to prevent overwhelming the network
                time.sleep(0.05)
            
            # Calculate scan duration
            duration = time.time() - start_time
            
            # Prepare completion message
            if self.should_stop:
                message = f"Vulnerability scan stopped after {duration:.1f} seconds. Found {len(self.vulnerabilities)} potential vulnerabilities."
            else:
                message = f"Vulnerability scan completed in {duration:.1f} seconds. Found {len(self.vulnerabilities)} potential vulnerabilities."
            
            # Emit scan complete signal
            self.scan_complete.emit(self.vulnerabilities.copy(), message)
            
            # Call callback if provided
            if callback:
                callback(self.vulnerabilities.copy(), message)
                
        except Exception as e:
            logger.error(f"Error in vulnerability scan: {e}")
            
            # Emit scan complete with error message
            error_message = f"Vulnerability scan failed: {str(e)}"
            self.scan_complete.emit(self.vulnerabilities.copy(), error_message)
            
            # Call callback if provided
            if callback:
                callback(self.vulnerabilities.copy(), error_message)
        
        finally:
            # Ensure running state is reset
            self.running = False
    
    def _scan_target(self, target: Dict):
        """Scan a single target for vulnerabilities.
        
        Args:
            target: Dictionary with target information ('ip', 'mac', etc.)
        """
        target_ip = target.get('ip')
        if not target_ip:
            logger.warning("Target missing IP address, skipping")
            return
        
        logger.info(f"Scanning target {target_ip} for vulnerabilities")
        
        # Basic info about the target
        target_info = {
            'ip': target_ip,
            'mac': target.get('mac', ''),
            'name': target.get('name', ''),
            'vendor': target.get('vendor', ''),
            'scan_time': datetime.now()
        }
        
        try:
            # Step 1: Port scan to find open ports
            open_ports = self._scan_ports(target_ip)
            if self.should_stop:
                return
                
            # Step 2: Service identification on open ports
            services = self._identify_services(target_ip, open_ports)
            if self.should_stop:
                return
                
            # Step 3: Check for common vulnerabilities
            self._check_vulnerabilities(target_info, open_ports, services)
            
        except Exception as e:
            logger.error(f"Error scanning target {target_ip}: {e}")
    
    def _scan_ports(self, ip: str) -> Dict[int, bool]:
        """Scan for open ports on the target.
        
        Args:
            ip: IP address to scan
            
        Returns:
            Dict[int, bool]: Dictionary of port numbers and their open status
        """
        result = {}
        scan_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        scan_socket.settimeout(self.port_scan_timeout)
        
        for port in self.common_ports:
            # Check if we should stop
            if self.should_stop:
                scan_socket.close()
                return result
                
            try:
                connection = scan_socket.connect_ex((ip, port))
                is_open = (connection == 0)
                result[port] = is_open
                
                if is_open:
                    logger.debug(f"Port {port} is open on {ip}")
                
                # Close the connection
                scan_socket.close()
                scan_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                scan_socket.settimeout(self.port_scan_timeout)
                
            except Exception as e:
                logger.debug(f"Error scanning port {port} on {ip}: {e}")
                result[port] = False
        
        scan_socket.close()
        return result
    
    def _identify_services(self, ip: str, open_ports: Dict[int, bool]) -> Dict[int, Dict]:
        """Identify services running on open ports.
        
        Args:
            ip: IP address of the target
            open_ports: Dictionary of port numbers and their open status
            
        Returns:
            Dict[int, Dict]: Dictionary of port numbers and service information
        """
        services = {}
        
        for port, is_open in open_ports.items():
            # Skip closed ports
            if not is_open:
                continue
                
            # Check if we should stop
            if self.should_stop:
                return services
            
            # Try to identify the service
            service_info = self._probe_service(ip, port)
            if service_info:
                services[port] = service_info
                logger.debug(f"Identified service on {ip}:{port} - {service_info.get('name', 'Unknown')}")
        
        return services
    
    def _probe_service(self, ip: str, port: int) -> Dict:
        """Probe a port to identify the running service.
        
        Args:
            ip: IP address of the target
            port: Port number to probe
            
        Returns:
            Dict: Service information or empty dict if not identified
        """
        # Common protocol probes and their expected responses
        probe_data = {
            21: b"",  # FTP - just connect
            22: b"",  # SSH - just connect
            23: b"",  # Telnet - just connect
            25: b"HELO arpguard.local\r\n",  # SMTP
            80: b"GET / HTTP/1.0\r\nHost: %b\r\n\r\n" % ip.encode(),  # HTTP
            110: b"",  # POP3 - just connect
            143: b"",  # IMAP - just connect
            443: b"",  # HTTPS - just connect, SSL will be handled separately
            3306: b"",  # MySQL - just connect
            3389: b"",  # RDP - just connect
            5900: b""   # VNC - just connect
        }
        
        # Port to service name mapping
        port_service_map = {
            21: "FTP",
            22: "SSH",
            23: "Telnet",
            25: "SMTP",
            53: "DNS",
            80: "HTTP",
            110: "POP3",
            139: "NetBIOS",
            143: "IMAP",
            443: "HTTPS",
            445: "SMB",
            993: "IMAPS",
            995: "POP3S",
            3306: "MySQL",
            3389: "RDP",
            5900: "VNC",
            8080: "HTTP-Proxy"
        }
        
        # Get default service name based on port
        default_service = {
            'name': port_service_map.get(port, "Unknown"),
            'banner': "",
            'version': ""
        }
        
        # For some ports, just return the default service name
        if port not in probe_data:
            return default_service
        
        # Try to connect and get a banner
        try:
            probe_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            probe_socket.settimeout(self.port_scan_timeout)
            probe_socket.connect((ip, port))
            
            # Send probe data if needed
            if probe_data[port]:
                probe_socket.send(probe_data[port])
            
            # Try to receive a banner
            banner = probe_socket.recv(1024)
            probe_socket.close()
            
            # Process the banner
            banner_str = banner.decode('utf-8', errors='ignore').strip()
            
            # Update service info
            service_info = {
                'name': default_service['name'],
                'banner': banner_str,
                'version': self._extract_version(banner_str, default_service['name'])
            }
            
            return service_info
            
        except Exception as e:
            logger.debug(f"Error probing service on {ip}:{port} - {e}")
            return default_service
    
    def _extract_version(self, banner: str, service_name: str) -> str:
        """Extract version information from a service banner.
        
        Args:
            banner: Service banner text
            service_name: Name of the service
            
        Returns:
            str: Extracted version or empty string
        """
        # Service-specific version extraction patterns
        patterns = {
            "SSH": r"SSH-2.0-(OpenSSH_[^\s]+)",
            "FTP": r"^220[- ]([^\r\n]+)",
            "SMTP": r"^220[- ]([^\r\n]+)",
            "HTTP": r"Server: ([^\r\n]+)",
            "POP3": r"^[+]OK ([^\r\n]+)",
            "IMAP": r"^[*] OK ([^\r\n]+)",
            "MySQL": r"([0-9]+\.[0-9]+\.[0-9]+)"
        }
        
        # Check if we have a pattern for this service
        if service_name in patterns:
            pattern = patterns[service_name]
            match = re.search(pattern, banner)
            if match:
                return match.group(1)
        
        return ""
    
    def _check_vulnerabilities(self, target_info: Dict, open_ports: Dict[int, bool], services: Dict[int, Dict]):
        """Check for vulnerabilities based on open ports and services.
        
        Args:
            target_info: Basic information about the target
            open_ports: Dictionary of port numbers and their open status
            services: Dictionary of port numbers and service information
        """
        # Get vulnerability definitions
        port_vulns = self.vulnerability_definitions.get("port_vulnerabilities", {})
        service_patterns = self.vulnerability_definitions.get("service_patterns", {})
        
        # Step 1: Check for port-based vulnerabilities
        for port, is_open in open_ports.items():
            if not is_open:
                continue
                
            # Check if we should stop
            if self.should_stop:
                return
                
            # Check if this port is associated with a known vulnerability
            port_str = str(port)
            if port_str in port_vulns:
                vuln_def = port_vulns[port_str]
                
                # Create vulnerability record
                vulnerability = {
                    'target': target_info.copy(),
                    'port': port,
                    'service': services.get(port, {}).get('name', 'Unknown'),
                    'name': vuln_def.get('name', 'Unknown Vulnerability'),
                    'description': vuln_def.get('description', ''),
                    'severity': vuln_def.get('severity', 'low'),
                    'recommendations': vuln_def.get('recommendations', []),
                    'detection_time': datetime.now(),
                    'details': {
                        'method': 'port-based',
                        'banner': services.get(port, {}).get('banner', '')
                    }
                }
                
                # Add to vulnerability list
                self.vulnerabilities.append(vulnerability)
                
                # Emit vulnerability found signal
                self.vulnerability_found.emit(vulnerability)
                
                logger.info(f"Found potential vulnerability on {target_info['ip']}:{port} - {vulnerability['name']}")
        
        # Step 2: Check for service-based vulnerabilities
        for port, service_info in services.items():
            # Check if we should stop
            if self.should_stop:
                return
                
            service_name = service_info.get('name', '')
            banner = service_info.get('banner', '')
            
            if service_name in service_patterns:
                pattern_info = service_patterns[service_name]
                pattern = pattern_info.get('pattern', '')
                
                # Skip if no pattern
                if not pattern:
                    continue
                    
                # Check if the banner matches the vulnerability pattern
                if re.search(pattern, banner):
                    # Create vulnerability record
                    vulnerability = {
                        'target': target_info.copy(),
                        'port': port,
                        'service': service_name,
                        'name': pattern_info.get('name', 'Unknown Vulnerability'),
                        'description': pattern_info.get('description', ''),
                        'severity': pattern_info.get('severity', 'low'),
                        'recommendations': pattern_info.get('recommendations', []),
                        'detection_time': datetime.now(),
                        'details': {
                            'method': 'service-pattern',
                            'banner': banner,
                            'version': service_info.get('version', '')
                        }
                    }
                    
                    # Add to vulnerability list
                    self.vulnerabilities.append(vulnerability)
                    
                    # Emit vulnerability found signal
                    self.vulnerability_found.emit(vulnerability)
                    
                    logger.info(f"Found potential vulnerability on {target_info['ip']}:{port} - {vulnerability['name']}")
        
        # Step 3: Check for SSL/TLS vulnerabilities if HTTPS is present
        if 443 in open_ports and open_ports[443]:
            self._check_ssl_vulnerabilities(target_info)
    
    def _check_ssl_vulnerabilities(self, target_info: Dict):
        """Check for SSL/TLS vulnerabilities.
        
        Args:
            target_info: Basic information about the target
        """
        # This is a simplified implementation
        # A real implementation would check for weak ciphers, vulnerable SSL/TLS versions, etc.
        
        # Skip this check on non-Windows systems for now
        if platform.system() != "Windows":
            return
            
        try:
            # Use OpenSSL or similar tools to check for SSL vulnerabilities
            # This is just a placeholder for demonstration
            target_ip = target_info['ip']
            
            # Simulated check: try to connect with SSLv3 (vulnerable)
            cmd = f"echo Q | openssl s_client -connect {target_ip}:443 -ssl3"
            process = subprocess.Popen(
                cmd, 
                shell=True, 
                stdout=subprocess.PIPE, 
                stderr=subprocess.PIPE
            )
            stdout, stderr = process.communicate(timeout=self.scan_timeout)
            output = stdout.decode('utf-8', errors='ignore')
            
            # Check if SSLv3 is supported (this is vulnerable)
            if "CONNECTED" in output and "handshake failure" not in output:
                weak_ciphers = self.vulnerability_definitions.get("weak_ciphers", {}).get("SSL", {})
                
                # Create vulnerability record
                vulnerability = {
                    'target': target_info.copy(),
                    'port': 443,
                    'service': 'HTTPS',
                    'name': weak_ciphers.get('name', 'SSL/TLS Vulnerability'),
                    'description': weak_ciphers.get('description', 'Server supports weak SSL/TLS protocols.'),
                    'severity': weak_ciphers.get('severity', 'high'),
                    'recommendations': weak_ciphers.get('recommendations', []),
                    'detection_time': datetime.now(),
                    'details': {
                        'method': 'ssl-check',
                        'issue': 'Supports SSLv3 (vulnerable to POODLE attack)'
                    }
                }
                
                # Add to vulnerability list
                self.vulnerabilities.append(vulnerability)
                
                # Emit vulnerability found signal
                self.vulnerability_found.emit(vulnerability)
                
                logger.info(f"Found SSL vulnerability on {target_info['ip']}:443")
                
        except Exception as e:
            logger.debug(f"Error checking SSL vulnerabilities on {target_info['ip']}: {e}")


# Singleton instance
_vulnerability_scanner_instance = None

def get_vulnerability_scanner():
    """Get or create the vulnerability scanner singleton instance.
    
    Returns:
        VulnerabilityScanner: The singleton instance of the vulnerability scanner
    """
    global _vulnerability_scanner_instance
    
    if _vulnerability_scanner_instance is None:
        _vulnerability_scanner_instance = VulnerabilityScanner()
        
    return _vulnerability_scanner_instance 