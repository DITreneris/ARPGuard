import unittest
from unittest.mock import Mock, patch
import sys
from PyQt5.QtWidgets import QApplication
from PyQt5.QtTest import QTest
from PyQt5.QtCore import Qt

# Add the app directory to the Python path
sys.path.append('app')

from components.vulnerability_view import VulnerabilityView
from components.vulnerability_scanner import VulnerabilityScanner

class TestVulnerabilityView(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        """Set up the QApplication instance once for all tests"""
        cls.app = QApplication(sys.argv)
        
    def setUp(self):
        """Create a fresh VulnerabilityView instance for each test"""
        # Mock the VulnerabilityScanner dependency
        self.mock_scanner = Mock(spec=VulnerabilityScanner)
        with patch('components.vulnerability_view.VulnerabilityScanner', return_value=self.mock_scanner):
            self.view = VulnerabilityView()
        
    def tearDown(self):
        """Clean up after each test"""
        self.view.close()
        self.view.deleteLater()
        
    def test_view_initialization(self):
        """Test if vulnerability view initializes correctly with all UI components"""
        # Check if main components are initialized
        self.assertIsNotNone(self.view)
        self.assertIsNotNone(self.view.vuln_table)
        self.assertIsNotNone(self.view.risk_filter)
        self.assertIsNotNone(self.view.port_filter)
        self.assertIsNotNone(self.view.ip_filter)
        
        # Check if the main layout is set
        self.assertIsNotNone(self.view.layout())
        
        # Check if the window title is set correctly
        self.assertEqual(self.view.windowTitle(), "Vulnerability Scanner")
        
    def test_vulnerability_display(self):
        """Test vulnerability display functionality"""
        # Create a test vulnerability item
        test_vuln = {
            "ip": "192.168.1.100",
            "port": 80,
            "service": "HTTP",
            "risk_level": "High",
            "description": "SQL Injection vulnerability detected",
            "timestamp": "2024-03-29 10:00:00"
        }
        
        # Add the vulnerability item to the view
        self.view.add_vulnerability(test_vuln)
        
        # Verify the vulnerability item is displayed correctly
        self.assertEqual(self.view.vuln_table.rowCount(), 1)
        self.assertEqual(self.view.vuln_table.item(0, 0).text(), "192.168.1.100")
        self.assertEqual(self.view.vuln_table.item(0, 1).text(), "80")
        self.assertEqual(self.view.vuln_table.item(0, 2).text(), "HTTP")
        self.assertEqual(self.view.vuln_table.item(0, 3).text(), "High")
        
    def test_risk_level_filtering(self):
        """Test vulnerability filtering by risk level"""
        # Add test vulnerability items with different risk levels
        test_vulns = [
            {"ip": "192.168.1.100", "port": 80, "service": "HTTP", "risk_level": "High"},
            {"ip": "192.168.1.101", "port": 443, "service": "HTTPS", "risk_level": "Medium"},
            {"ip": "192.168.1.102", "port": 22, "service": "SSH", "risk_level": "Low"}
        ]
        
        for vuln in test_vulns:
            self.view.add_vulnerability(vuln)
            
        # Verify all vulnerabilities are initially displayed
        self.assertEqual(self.view.vuln_table.rowCount(), 3)
        
        # Set filter to "High" risk
        self.view.risk_filter.setCurrentText("High")
        QTest.keyPress(self.view.risk_filter, Qt.Key_Return)
        
        # Verify only High risk vulnerabilities are shown
        visible_rows = 0
        for row in range(self.view.vuln_table.rowCount()):
            if not self.view.vuln_table.isRowHidden(row):
                visible_rows += 1
                self.assertEqual(self.view.vuln_table.item(row, 3).text(), "High")
        
        self.assertEqual(visible_rows, 1)
        
    def test_port_filtering(self):
        """Test vulnerability filtering by port"""
        # Add test vulnerability items with different ports
        test_vulns = [
            {"ip": "192.168.1.100", "port": 80, "service": "HTTP", "risk_level": "High"},
            {"ip": "192.168.1.101", "port": 443, "service": "HTTPS", "risk_level": "Medium"},
            {"ip": "192.168.1.102", "port": 80, "service": "HTTP-ALT", "risk_level": "Low"}
        ]
        
        for vuln in test_vulns:
            self.view.add_vulnerability(vuln)
            
        # Set filter to port 80
        self.view.port_filter.setText("80")
        QTest.keyPress(self.view.port_filter, Qt.Key_Return)
        
        # Verify only port 80 vulnerabilities are shown
        visible_rows = 0
        for row in range(self.view.vuln_table.rowCount()):
            if not self.view.vuln_table.isRowHidden(row):
                visible_rows += 1
                self.assertEqual(self.view.vuln_table.item(row, 1).text(), "80")
        
        self.assertEqual(visible_rows, 2)
        
    def test_ip_filtering(self):
        """Test vulnerability filtering by IP address"""
        # Add test vulnerability items with different IPs
        test_vulns = [
            {"ip": "192.168.1.100", "port": 80, "service": "HTTP", "risk_level": "High"},
            {"ip": "192.168.1.101", "port": 443, "service": "HTTPS", "risk_level": "Medium"},
            {"ip": "10.0.0.1", "port": 22, "service": "SSH", "risk_level": "Low"}
        ]
        
        for vuln in test_vulns:
            self.view.add_vulnerability(vuln)
            
        # Set filter to 192.168.1 subnet
        self.view.ip_filter.setText("192.168.1")
        QTest.keyPress(self.view.ip_filter, Qt.Key_Return)
        
        # Verify only matching IP vulnerabilities are shown
        visible_rows = 0
        for row in range(self.view.vuln_table.rowCount()):
            if not self.view.vuln_table.isRowHidden(row):
                visible_rows += 1
                self.assertTrue(self.view.vuln_table.item(row, 0).text().startswith("192.168.1"))
        
        self.assertEqual(visible_rows, 2)
        
    def test_scan_initiation(self):
        """Test initiating a vulnerability scan"""
        # Mock the scan method of the scanner
        self.mock_scanner.scan_network = Mock()
        
        # Set up target parameters
        target_ip = "192.168.1.0/24"
        target_ports = "80,443,8080"
        scan_intensity = "Normal"
        
        # Set the scan parameters in the UI
        self.view.target_input.setText(target_ip)
        self.view.ports_input.setText(target_ports)
        self.view.intensity_combo.setCurrentText(scan_intensity)
        
        # Trigger the scan
        self.view.start_scan()
        
        # Verify the scanner was called with the correct parameters
        self.mock_scanner.scan_network.assert_called_once()
        # Extract the arguments the mock was called with
        args, kwargs = self.mock_scanner.scan_network.call_args
        self.assertEqual(args[0], target_ip)  # First arg should be target IP
        self.assertEqual(kwargs.get('ports', None), target_ports)
        self.assertEqual(kwargs.get('intensity', None), scan_intensity)

    def test_multiple_vulnerability_display(self):
        """Test displaying multiple vulnerabilities"""
        # Add 10 test vulnerabilities
        for i in range(10):
            vuln = {
                "ip": f"192.168.1.{100+i}",
                "port": 80 + i*10,
                "service": f"Service-{i}",
                "risk_level": "Medium",
                "description": f"Test vulnerability {i}",
                "timestamp": "2024-03-29 10:00:00"
            }
            self.view.add_vulnerability(vuln)
            
        # Verify all vulnerabilities are displayed
        self.assertEqual(self.view.vuln_table.rowCount(), 10)
        
        # Verify sorting works by clicking on the header
        self.view.vuln_table.horizontalHeader().sectionClicked.emit(1)  # Sort by port
        
        # Since we can't directly check the sorting in a test, we just ensure no errors occur
        # and the row count remains the same
        self.assertEqual(self.view.vuln_table.rowCount(), 10)

if __name__ == '__main__':
    unittest.main() 